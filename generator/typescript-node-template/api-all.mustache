{{#apiInfo}}
{{#apis}}
{{#operations}}
import { {{ classname }}, {{ classname }}Methods } from './{{ classFilename }}';
export { {{ classname }}Methods } from './{{ classFilename }}';
{{/operations}}
{{#withInterfaces}}
// export * from './{{ classFilename }}Interface'
{{/withInterfaces}}
{{/apis}}
import fetch, {Response} from 'node-fetch';

let defaultBasePath = '{{{basePath}}}';

export interface MiroEndpoints extends
    {{#apis}}
    {{#operations}}{{ classname }}Methods{{/operations}}{{^-last}}, {{/-last}}
    {{/apis}} {}

export function MiroApi (accessToken: string|(() => Promise<string>), basePath: string = defaultBasePath, logger?: (...thing: any) => void): MiroEndpoints {
    return {
        {{#apis}}
        {{#operations}}...{{ classname }}(accessToken, basePath, logger){{/operations}},
        {{/apis}}
    }
}

export class HttpError extends Error {
    constructor (public response: Response, public body: any, public statusCode?: number) {
        super('HTTP request failed');
        this.name = 'HttpError';
    }
}

export async function makeJsonRequest(token: string, method: string, url: URL, body?: string, logger?: (...thing: any) => void) {
    const options = {
        method,
        headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Authorization': `Bearer ${token}`
        },
        body
    }

    const hasLogger = typeof logger === 'function'

    if (hasLogger) logger('FETCH', url.toString(), options)

    const response = await fetch(url, options)

    if (hasLogger) logger('RESPONSE', response)

    let bodyAsJson: unknown
    try {
        bodyAsJson = await response.json()
    } catch (err) {
        // Body doesn't have valid json
    }

    if (hasLogger && bodyAsJson) logger('BODY', bodyAsJson)

    if (!response.ok) {
        throw new HttpError(response, bodyAsJson, response.status)
    }

    return {bodyAsJson, response}
}

{{/apiInfo}}
